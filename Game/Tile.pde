class Tile {
  /*A Tile holds properties of the terrain */
  final int X;  //x-coordinate
  final int Y;  //y-coordinate
  LandUse landU;
  
  //Every derived variable that is summed over all Tiles in WS is stored as constants, to avoid expensive calculation over each frame.
  float pollution;        //Source pollution this Tile generates
  float decayPollution;      //Pollution entering river from this tile after decay
  float actualProfit = 0;  //Actual profit made by the landU at this tile
  
  Tile(LandUse lu, int xp, int yp) {
     /* Constructor: Initializes Tile with LandUse lu, and integer slope sl, soil so values */
     X = xp;
     Y = yp;
     landU = lu;     
  }

  boolean isDirt() {
    return (landU.isDirt());
  }
  boolean isForest() {
    return (landU.isForest());
  }
  boolean isFactory() {
    return (landU.isFactory());
  }
  boolean isFarm() {
    return (landU.isFarm());
  }
  boolean isHouse() {
    return (landU.isHouse());
  }
  boolean isRiver() {
    return (landU.isRiver());
  }
  
  void changeLandUse(LandUse lu) {
    /* Changes the LandUse held by the Tile to lu */
    landU = lu;
    pollution = lu.basePollution;
    if (! (lu.isForest()) && !(lu.isRiver())) {
      decayPollution = lu.calcDecayPollution(distToRiver());
    } else decayPollution = lu.basePollution;
    actualProfit = lu.calcActualProfit(distToRiver());
  }
  
  float distToRiver() {
    /* Helper: Returns the distance of location this to closest River Tile. */
    float minDist = Float.MAX_VALUE;
    for (Tile t: riverTiles) {
      float d = dist(X, Y, t.getX(), t.getY());
      if (d < minDist) minDist = d;
    }
    return minDist;
  }
  
  LandUse getLandUse() {
    /* Returns the LandUse object of the Tile */
    return landU;
  }
  
  float getTilePollution() {
    /* Returns the pollution generated by the LandUse held by the Tile */
    if (! (this.isRiver())) {
      return pollution;
    }else return 0;
  }
  
  float getDecayPollution() {
    if (! (this.isRiver())) {
      return decayPollution;
    }else return 0;
  }
    
  int getBaseProfit() {
    /* Returns the baseProfit of the landUse of this Tile */
    return landU.getBaseProfit();
  }
  
  float getActualProfit() {
    /* Returns the actual profit gained at this tile */
    return actualProfit;
  }
  
  void update() {
    if (! (this.isDirt()) && !(this.isRiver()))
      pollution = landU.basePollution;
    if (! (this.isForest()) && !(this.isRiver()))
       decayPollution = landU.calcDecayPollution(distToRiver());
    else decayPollution = pollution;
  }
  
  int getX(){
    /* Returns the XPOS of the tile */
    return X;
  }
  
  int getY(){
    /* Returns the XPOS of the tile */
    return Y;
  }
  
  @Override
  public String toString() {
    return "<" + str(X) + ", " + str(Y)+ ">";
  }
}